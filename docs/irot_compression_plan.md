# irot compression plan (vdM → rifdock RotamerBits)

## Why this exists

rifdock’s RIF formats store `rotamer_id` in a **bit-packed field** (`RotamerBits`), which caps the number of distinct ids:
- 9 bits ⇒ 512
- 10 bits ⇒ 1024

Meanwhile, Combs vdMs already come with `cluster_number`, but cluster counts are **>1024** for MTX-relevant CGs, so we cannot use `cluster_number` directly as `rotamer_id`.

## Quantitative snapshot (local Combs2024 DB)

Source: `processed/06_stats/mtx_vdm_db_stats.json` generated by `scripts/06_stats/01_run_mtx_vdm_db_stats.sh`.

For the CGs used by MTX:
- Instances (unique `(rota, CG, probe_name)`):
  - `coo`: 348,142
  - `conh2`: 303,932
  - `ccn`: 145,248
  - `ph`: 417,170
  - `bb_cnh`: 314,744
- Distinct Combs `cluster_number`:
  - `coo`: 4,182
  - `conh2`: 4,097
  - `ccn`: 2,062
  - `ph`: 4,143
  - `bb_cnh`: 1,211

## Design goal

Define a bounded library of **irots** (interaction rotamers):
- `irot_id` ∈ `[0, 2^RotamerBits)` (≤512 or ≤1024)
- each irot corresponds to a **cluster representative** (or a small micro-ensemble) derived from Combs vdMs
- each irot has:
  - residue atoms in stub-local coordinates (like current `center_atom_xyz_stub_f32`)
  - a prior/score derived from vdM statistics (`C_score_ABPLE_A`, cluster rank, frequency)
  - optional satisfaction bookkeeping: which ligand polar atom(s) it can satisfy at a given placement

## Candidate strategies

### Strategy A (minimal rifdock changes): compress to ≤1024

Target RIF type: `Rot10Score6Sat16` (10-bit rotamer ids; still small and fast).

Compression procedure (deterministic):
1) Choose an “allowed residue set” per CG role (small, task-specific):
   - Example: if we only need to satisfy ligand polar atoms, we may not need all 20 AAs for every CG.
2) For each `(cg, aa)`:
   - compute cluster representatives in the **iFG frame**:
     - representative `X_ifg_to_stub` (mean/medoid)
     - representative residue atoms (medoid instance)
   - rank clusters by a mixture of:
     - frequency (#instances)
     - `C_score_ABPLE_A` / `cluster_rank_ABPLE_A`
     - diversity in geometry space (avoid keeping 100 near-duplicates)
3) Allocate a per-`(cg, aa)` budget `B_(cg,aa)` so that:
   - `Σ B_(cg,aa) ≤ 1024` (or ≤512), and budgets are deterministic and configurable.

Pros:
- no changes to rifdock packed storage.
- controllable size; fast.

Cons:
- must be careful that compression does not remove rare but essential interaction geometries.

### Strategy B (more invasive): widen RotamerBits to support raw clusters

Example: raise `RotamerBits` to 12 (4096) and introduce a new `rif_type` that keeps K reasonable.

Pros:
- closer to Combs clusters; less compression loss.

Cons:
- C++ code change; increases memory and file size; more difficult to maintain.

### Strategy C (hybrid): keep packed ids, store extra id map externally

Use 10-bit `irot_id` for coarse cluster family, but keep a per-bin side table that can point to many instances.

Pros:
- can retain more diversity than Strategy A.

Cons:
- requires new runtime logic; not a standard rifdock RIF.

## Chosen direction (C2)

We are choosing **C2**: patch rifdock to widen the packed `rotamer_id` capacity by introducing a new `rif_type`:
- `Rot12ScoreSat96` (4096 rotamer ids)

Implementation is in the vendored rifdock submodule:
- `external/rifdock/apps/rosetta/riflib/RifFactory.cc`

This removes the hard 512/1024 id cap for Combs cluster counts in the ~1k–4k range, at the cost of larger per-voxel storage.

### Quantitative tradeoff (packed entry sizes)

From rifdock’s `BOOST_STATIC_ASSERT(sizeof(...))` checks:
- `Rot10Score6Sat16` (10-bit ids, `uint16_t` backing): `sizeof(XformMap::Map::value_type) == 64` bytes
- `Rot12ScoreSat96` (12-bit ids, `uint32_t` backing): `sizeof(XformMap::Map::value_type) == 96` bytes

So the *per-occupied-voxel* payload grows by ~1.5× (96/64). Total `.rif.gz` size and memory usage still scale primarily with the number of occupied voxels, but this change is a real multiplier on that footprint.

## Still useful: compression as an optimization

Even with C2, compression can remain valuable for performance/memory (smaller irot libraries, faster generation), but it is no longer a correctness blocker.

## Next step

Validate the rifdock patch builds and can load/save a RIF with `rif_type=Rot12ScoreSat96` on `dg`, then proceed to implement `vdXform→RIF` export using this rif_type while keeping the Python pipeline as the correctness oracle.

Next action items:
- compute per-`(cg,aa)` cluster frequency tables (needed for a principled budget)
- implement a deterministic “cluster medoid” extraction for representatives
- define irot id assignment scheme and write it to disk for reproducibility
