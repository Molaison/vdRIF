# irot compression plan (vdM → rifdock RotamerBits)

## Why this exists

rifdock’s RIF formats store `rotamer_id` in a **bit-packed field** (`RotamerBits`), which caps the number of distinct ids:
- 9 bits ⇒ 512
- 10 bits ⇒ 1024

Meanwhile, Combs vdMs already come with `cluster_number`, but cluster counts are **>1024** for MTX-relevant CGs, so we cannot use `cluster_number` directly as `rotamer_id`.

## Quantitative snapshot (local Combs2024 DB)

Source: `processed/06_stats/mtx_vdm_db_stats.json` generated by `scripts/06_stats/01_run_mtx_vdm_db_stats.sh`.

For the CGs used by MTX:
- Instances (unique `(rota, CG, probe_name)`):
  - `coo`: 348,142
  - `conh2`: 303,932
  - `ccn`: 145,248
  - `ph`: 417,170
  - `bb_cnh`: 314,744
- Distinct Combs `cluster_number`:
  - `coo`: 4,182
  - `conh2`: 4,097
  - `ccn`: 2,062
  - `ph`: 4,143
  - `bb_cnh`: 1,211

## Design goal

Define a bounded library of **irots** (interaction rotamers):
- `irot_id` ∈ `[0, 2^RotamerBits)` (≤512 or ≤1024)
- each irot corresponds to a **cluster representative** (or a small micro-ensemble) derived from Combs vdMs
- each irot has:
  - residue atoms in stub-local coordinates (like current `center_atom_xyz_stub_f32`)
  - a prior/score derived from vdM statistics (`C_score_ABPLE_A`, cluster rank, frequency)
  - optional satisfaction bookkeeping: which ligand polar atom(s) it can satisfy at a given placement

## Candidate strategies

### Strategy A (minimal rifdock changes): compress to ≤1024

Target RIF type: `Rot10Score6Sat16` (10-bit rotamer ids; still small and fast).

Compression procedure (deterministic):
1) Choose an “allowed residue set” per CG role (small, task-specific):
   - Example: if we only need to satisfy ligand polar atoms, we may not need all 20 AAs for every CG.
2) For each `(cg, aa)`:
   - compute cluster representatives in the **iFG frame**:
     - representative `X_ifg_to_stub` (mean/medoid)
     - representative residue atoms (medoid instance)
   - rank clusters by a mixture of:
     - frequency (#instances)
     - `C_score_ABPLE_A` / `cluster_rank_ABPLE_A`
     - diversity in geometry space (avoid keeping 100 near-duplicates)
3) Allocate a per-`(cg, aa)` budget `B_(cg,aa)` so that:
   - `Σ B_(cg,aa) ≤ 1024` (or ≤512), and budgets are deterministic and configurable.

Pros:
- no changes to rifdock packed storage.
- controllable size; fast.

Cons:
- must be careful that compression does not remove rare but essential interaction geometries.

### Strategy B (more invasive): widen RotamerBits to support raw clusters

Example: raise `RotamerBits` to 12 (4096) and introduce a new `rif_type` that keeps K reasonable.

Pros:
- closer to Combs clusters; less compression loss.

Cons:
- C++ code change; increases memory and file size; more difficult to maintain.

### Strategy C (hybrid): keep packed ids, store extra id map externally

Use 10-bit `irot_id` for coarse cluster family, but keep a per-bin side table that can point to many instances.

Pros:
- can retain more diversity than Strategy A.

Cons:
- requires new runtime logic; not a standard rifdock RIF.

## Recommended next step

Start with Strategy A for a minimal MVP that can be exported into rifdock formats, while keeping the current Python pipeline as the correctness oracle.

Next action items:
- compute per-`(cg,aa)` cluster frequency tables (needed for a principled budget)
- implement a deterministic “cluster medoid” extraction for representatives
- define irot id assignment scheme and write it to disk for reproducibility

