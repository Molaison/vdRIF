{"id":"rifvdm-02v","title":"Survey Combs2024 vdM database schema + size drivers; decide re-encoding format","description":"Inspect Combs2024 vdM parquet DB schema + decide re-encoding format. Local DB path: ~/practice_arena/050_test_COMBS/Combs2024/database/database/ (vdMs/ ~5.2GB, 354 *.parquet.gzip across 18 CG folders). Identify minimal fields needed for vdM-\u003evdXform: cluster_id, residue identity, interacting-atom mapping, transform from CG frame to residue stub, and priors from C_score/cluster_rank.","notes":"Schema+scale snapshot (local DB ~/practice_arena/.../vdMs): 354 parquet files (~5.2GB). Instance key is (rota, CG, probe_name) and in sampled files each instance is a 3-residue microenvironment: chain=='Y' are iFG/CG atoms for superposition; chain=='X' are the 3 residues. For MTX CG typing: 8 CG occurrences across ph/coo/ccn/conh2; those CG types total ~584k unique probe_name in DB; naive placement across all occurrences is ~1.2M 3mers before pruning.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-09T09:54:18.71222653+08:00","created_by":"zpzeng","updated_at":"2026-01-09T10:54:22.114933163+08:00","closed_at":"2026-01-09T10:54:22.114933163+08:00","close_reason":"Closed"}
{"id":"rifvdm-1qi","title":"Survey rifgen sampling loops + scaling limits (rotamers, hb geoms, per-voxel caps)","description":"Read rifdock/rifgen code paths to quantify sampling complexity and memory: how many RelRotPos per HB job, how per-voxel top-K is enforced (RotamerScores\u003cN\u003e), what rif_type options imply, what defaults in rifgen.flag mean. Produce scaling spreadsheet + hard limits + design constraints for vdM insertion.","notes":"Findings: (1) RIF per-voxel top-K is fixed (e.g., RotScore64 K=28; RotScoreSat K=14; RotScoreSat_2x16 K=19). (2) RIF rotamer id is bit-packed: most rif types use RotamerBits=9 (max 512 ids); Rot10Score6Sat16 uses RotamerBits=10 (max 1024). This is a hard cap for any vdM-\u003eRIF export. (3) UserHotspots generator is non-deterministic by default (seed time(0)). See docs/design_plan.md for details.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-09T09:54:15.371968935+08:00","created_by":"zpzeng","updated_at":"2026-01-09T10:54:21.999085449+08:00","closed_at":"2026-01-09T10:54:21.999085449+08:00","close_reason":"Closed"}
{"id":"rifvdm-2j5","title":"Write docs: quickstart + data format spec + milestones","description":"Create docs/quickstart.md, docs/changelog.md, docs/takeaway.md and keep them updated. Quickstart should show repo layout, how to download Combs DB, how to run converter + candidate generation, and how to reproduce outputs.","notes":"Updated docs: quickstart now uses uv (3.11) + rdkit extra; design_plan now includes MTX CG typing + DB scale + RotamerBits cap; takeaway updated with env notes; changelog updated. Remaining doc TODO: add converter/candidate scripts once implemented.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-09T09:54:39.868382846+08:00","created_by":"zpzeng","updated_at":"2026-01-09T10:54:28.265901897+08:00","closed_at":"2026-01-09T10:54:28.265901897+08:00","close_reason":"Closed","dependencies":[{"issue_id":"rifvdm-2j5","depends_on_id":"rifvdm-k8y","type":"blocks","created_at":"2026-01-09T09:58:06.216809814+08:00","created_by":"zpzeng"}]}
{"id":"rifvdm-50s","title":"Design vdM-\u003evdXform compact file format + conversion script from parquet","description":"Design on-disk format (vdXform) optimized for rifgen reading: per-CG list of cluster representatives with rigid transform(s), residue identity, score priors (C_score, cluster_rank), and optional metadata. Also implement converter from Combs parquet DB.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-09T09:54:27.945797593+08:00","created_by":"zpzeng","updated_at":"2026-01-09T09:55:07.550734165+08:00","dependencies":[{"issue_id":"rifvdm-50s","depends_on_id":"rifvdm-02v","type":"blocks","created_at":"2026-01-09T09:58:02.229478513+08:00","created_by":"zpzeng"},{"issue_id":"rifvdm-50s","depends_on_id":"rifvdm-1qi","type":"blocks","created_at":"2026-01-09T09:58:03.275593283+08:00","created_by":"zpzeng"},{"issue_id":"rifvdm-50s","depends_on_id":"rifvdm-c8x","type":"blocks","created_at":"2026-01-09T10:07:45.751609108+08:00","created_by":"zpzeng"}]}
{"id":"rifvdm-8np","title":"Define ligand polar-atom/functional-group typing + CG frames compatible with Combs CGs","description":"Define deterministic ligand polar-atom typing and Combs CG frames. Use existing local tool for CG detection + atom mapping: ~/practice_arena/050_test_COMBS/vdm_designer/vdm_core/generate_cg_atommap.py (SMARTS + connectivity ordering aligned with Combs cg_dicts.txt). Output should include per-CG ligand atom ordering (lgd_sel) matching correspond_names, and frame definition rules for placement/superposition.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-09T09:54:23.472744324+08:00","created_by":"zpzeng","updated_at":"2026-01-09T10:06:02.435921948+08:00"}
{"id":"rifvdm-azr","title":"Run CG atom mapping for MTX ligand pose","description":"Use local script generate_cg_atommap.py to identify Combs CGs in MTX bound-pose ligand and write deterministic JSON mapping. Input: inputs/01_cgmap/MTX.pdb (copied from ligand bench). Output: outputs/01_cgmap/MTX_cg_atommap.json + logs.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-09T10:12:21.746969705+08:00","created_by":"zpzeng","updated_at":"2026-01-09T10:35:25.274389794+08:00","closed_at":"2026-01-09T10:35:25.274389794+08:00","close_reason":"Closed"}
{"id":"rifvdm-c8x","title":"Set up modern Python env for parquet IO (pyarrow) + OR-Tools solver","description":"Blocker for parquet -\u003e vdXform conversion and deterministic motif solver. Current workspace python3=3.6.8 lacks pyarrow/fastparquet; plan: set up a modern Python env using **uv** (preferred) or pixi. Repo includes pyproject.toml (python\u003e=3.11) with deps: numpy/pandas/pyarrow/ortools; run: uv python install 3.11 \u0026\u0026 uv lock \u0026\u0026 uv sync. Document exact steps + any platform caveats.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-09T10:07:41.809944485+08:00","created_by":"zpzeng","updated_at":"2026-01-09T10:35:25.31681036+08:00","closed_at":"2026-01-09T10:35:25.31681036+08:00","close_reason":"Closed"}
{"id":"rifvdm-e5b","title":"Implement deterministic motif solver: cover all ligand polar atoms with 8–15 residues","description":"Implement deterministic selection of 8–15 residue placements that cover all ligand polar atoms (hard constraint). Likely ILP/CP-SAT with clash constraints and optional buriedness priors. Output motif PDB + JSON audit trail.","status":"open","priority":1,"issue_type":"feature","created_at":"2026-01-09T09:54:35.241526068+08:00","created_by":"zpzeng","updated_at":"2026-01-09T09:55:09.831531219+08:00","dependencies":[{"issue_id":"rifvdm-e5b","depends_on_id":"rifvdm-kx4","type":"blocks","created_at":"2026-01-09T09:58:05.469550596+08:00","created_by":"zpzeng"},{"issue_id":"rifvdm-e5b","depends_on_id":"rifvdm-8np","type":"blocks","created_at":"2026-01-09T09:58:05.82099803+08:00","created_by":"zpzeng"},{"issue_id":"rifvdm-e5b","depends_on_id":"rifvdm-c8x","type":"blocks","created_at":"2026-01-09T10:07:45.785180444+08:00","created_by":"zpzeng"}]}
{"id":"rifvdm-k8y","title":"[EPIC] vdM × RIFGen: deterministic fully-polar-satisfied ligand motif","description":"Goal: Given a ligand bound pose, generate a deterministic 8–15 residue motif such that every ligand polar atom is satisfied (H-bonds/salt bridges), using vdM statistics (Combs) for geometry priors and RIFGen-style discretized 6D field for scalable enumeration/compression. Deliverables: (1) candidate generator spec; (2) compact vdM transform library format; (3) motif solver spec; (4) docs + milestones.","status":"open","priority":1,"issue_type":"feature","created_at":"2026-01-09T09:54:11.762891669+08:00","created_by":"zpzeng","updated_at":"2026-01-09T09:54:59.327615696+08:00"}
{"id":"rifvdm-kx4","title":"MVP: deterministic vdM-based RIF generation path (no rifdock C++ changes)","description":"Prototype pipeline without modifying rifdock C++: generate a compressed candidate set from vdM DB in Python, optionally emit rifgen 'hotspots' with zero perturbation or a pre-binned list, and confirm determinism + size feasibility. This is a stepping stone to a native RifGeneratorVdM later.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-09T09:54:32.43253852+08:00","created_by":"zpzeng","updated_at":"2026-01-09T09:55:09.543393187+08:00","dependencies":[{"issue_id":"rifvdm-kx4","depends_on_id":"rifvdm-50s","type":"blocks","created_at":"2026-01-09T09:58:04.731832199+08:00","created_by":"zpzeng"},{"issue_id":"rifvdm-kx4","depends_on_id":"rifvdm-8np","type":"blocks","created_at":"2026-01-09T09:58:05.13518453+08:00","created_by":"zpzeng"}]}
